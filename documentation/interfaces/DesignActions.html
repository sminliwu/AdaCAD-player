<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>adacad-weaver documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">adacad-weaver documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li>Interfaces</li>
  <li
  >
  DesignActions</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/mixer/palette/subdraft/subdraft.component.ts</code>
        </p>




        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#icon" 
>
                                            icon
                                        </a>
                                </li>
                                <li>
                                        <a href="#value" 
>
                                            value
                                        </a>
                                </li>
                                <li>
                                        <a href="#viewValue" 
>
                                            viewValue
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="icon"></a>
                                        <span class="name "><b>icon</b>
                                            <a href="#icon">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>icon:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="value"></a>
                                        <span class="name "><b>value</b>
                                            <a href="#value">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>value:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="viewValue"></a>
                                        <span class="name "><b>viewValue</b>
                                            <a href="#viewValue">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>viewValue:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, OnInit, Input, Output, ViewChild, ElementRef, EventEmitter, HostListener, OnChanges, ChangeDetectionStrategy, SimpleChanges} from &#x27;@angular/core&#x27;;
import { Point, Interlacement, Bounds, DraftMap, Draft, LoomSettings } from &#x27;../../../core/model/datatypes&#x27;;
import { InkService } from &#x27;../../provider/ink.service&#x27;;
import { LayersService } from &#x27;../../provider/layers.service&#x27;;
import utilInstance from &#x27;../../../core/model/util&#x27;;
import { OperationService } from &#x27;../../provider/operation.service&#x27;;
import { TreeService } from &#x27;../../provider/tree.service&#x27;;
import { FileService } from &#x27;../../../core/provider/file.service&#x27;;
import { ViewportService } from &#x27;../../provider/viewport.service&#x27;;
import { MatDialog, MatDialogRef } from &#x27;@angular/material/dialog&#x27;;
import { DraftdetailComponent } from &#x27;../../modal/draftdetail/draftdetail.component&#x27;;
import { Cell } from &#x27;../../../core/model/cell&#x27;;
import { OperationComponent } from &#x27;../operation/operation.component&#x27;;
import { WorkspaceService } from &#x27;../../../core/provider/workspace.service&#x27;;
import { MaterialsService } from &#x27;../../../core/provider/materials.service&#x27;;
import { createDraft, getDraftName, initDraftWithParams, isSet, isUp, warps, wefts } from &#x27;../../../core/model/drafts&#x27;;




interface DesignActions{
  value: string;
  viewValue: string;
  icon: string;
}

@Component({
  selector: &#x27;app-subdraft&#x27;,
  templateUrl: &#x27;./subdraft.component.html&#x27;,
  styleUrls: [&#x27;./subdraft.component.scss&#x27;]
})



export class SubdraftComponent implements OnInit {

  @Input()  id: number; //generated by the tree service
  @Input()  default_cell: number;


  @Input()
  get scale(): number { return this._scale; }
  set scale(value: number) {
    this._scale &#x3D; value;
    this.rescale();
  }
  private _scale:number &#x3D; 5;

  @Input()
  get draft(): Draft { return this._draft; }
  set draft(value: Draft) {
    this._draft &#x3D; value;
    this.drawDraft(value);
  }

  private _draft:Draft &#x3D; null;

  @Input()
  get bounds(): Bounds { return this._bounds; }
  set bounds(value: Bounds) {
    this.updateViewport(value);
    this._bounds &#x3D; value;
    ;
  }

  private _bounds:Bounds &#x3D; {
    topleft: {x: 0, y: 0},
    width: 0, 
    height: 0
  };

  

  @Output() onSubdraftMove &#x3D; new EventEmitter &lt;any&gt;(); 
  @Output() onSubdraftDrop &#x3D; new EventEmitter &lt;any&gt;(); 
  @Output() onSubdraftStart &#x3D; new EventEmitter &lt;any&gt;(); 
  @Output() onDeleteCalled &#x3D; new EventEmitter &lt;any&gt;(); 
  @Output() onDuplicateCalled &#x3D; new EventEmitter &lt;any&gt;(); 
  @Output() onConnectionMade &#x3D; new EventEmitter &lt;any&gt;(); 
  @Output() onConnectionRemoved &#x3D; new EventEmitter &lt;any&gt;(); 
  @Output() onDesignAction &#x3D; new  EventEmitter &lt;any&gt;();
  @Output() onConnectionStarted:any &#x3D; new EventEmitter&lt;any&gt;();
  @Output() onSubdraftViewChange:any &#x3D; new EventEmitter&lt;any&gt;();
  @Output() onNameChange:any &#x3D; new EventEmitter&lt;any&gt;();
  @Output() onDraftToPlayer &#x3D; new EventEmitter&lt;any&gt;();

  @ViewChild(&#x27;bitmapImage&#x27;) bitmap: any;



  canvas: HTMLCanvasElement;
  cx: any;

  parent_id: number &#x3D; -1;

  /**
  * flag to tell if this is in a mode where it is looking foor a connectino
  */
  selecting_connection: boolean &#x3D; false;


  /**
   * hold the top left point as an interlacement, independent of scale
   */
  interlacement: Interlacement;

  // private _scale: number; 

  ink &#x3D; &#x27;neq&#x27;; //can be or, and, neq, not, splice

  counter:number  &#x3D;  0; // keeps track of how frequently to call the move functions
 
  counter_limit: number &#x3D; 50;  //this sets the threshold for move calls, lower number &#x3D;&#x3D; more calls
 
  last_ndx:Interlacement &#x3D; {i: -1, j:-1, si: -1}; //used to check if we should recalculate a move operation

  moving: boolean  &#x3D; false;
 
  disable_drag: boolean &#x3D; false;

  is_preview: boolean &#x3D; false;
 
  zndx &#x3D; 0;

  has_active_connection: boolean &#x3D; false;

  set_connectable:boolean &#x3D; false;

  modal: MatDialogRef&lt;DraftdetailComponent, any&gt;;

  draft_visible: boolean &#x3D; true;

  loom_settings: LoomSettings;

  constructor(private inks: InkService, 
    private layer: LayersService, 
    private ms: MaterialsService, 
    public tree: TreeService,
    private fs: FileService,
    private viewport: ViewportService,
    private dialog: MatDialog,
    private ws: WorkspaceService) { 

      this.zndx &#x3D; layer.createLayer();

  }

  ngOnInit(){

    if(!this.is_preview) this.parent_id &#x3D; this.tree.getSubdraftParent(this.id);
    const tl: Point &#x3D; this.viewport.getTopLeft();
    const tl_offset &#x3D; {x: tl.x + 60, y: tl.y};


    if(this.bounds.topleft.x &#x3D;&#x3D;&#x3D; 0 &amp;&amp; this.bounds.topleft.y &#x3D;&#x3D;&#x3D; 0) this.setPosition(tl_offset);
    this.interlacement &#x3D; utilInstance.resolvePointToAbsoluteNdx(this.bounds.topleft, this.scale);

    if(!this.is_preview) this.viewport.addObj(this.id, this.interlacement);

    const draft &#x3D; this.tree.getDraft(this.id);
    this.loom_settings &#x3D; this.tree.getLoomSettings(this.id);

    if(draft !&#x3D;&#x3D; undefined){
      this.bounds.width &#x3D; warps(draft.drawdown) * this.scale;
      this.bounds.height &#x3D; wefts(draft.drawdown) * this.scale;
    }else{
      this.bounds.width &#x3D; warps(draft.drawdown) * this.scale;
      this.bounds.height &#x3D; wefts(draft.drawdown) * this.scale;
    }

  }


  ngAfterViewInit() {


    this.canvas &#x3D; &lt;HTMLCanvasElement&gt; document.getElementById(this.id.toString());
    this.cx &#x3D; this.canvas.getContext(&quot;2d&quot;);
    this.drawDraft(this.draft); //force call here because it likely didn&#x27;t render previously. 

    this.rescale();
    this.updateViewport(this.bounds);

  }

  sendDraftToPlayer() {
    this.onDraftToPlayer.emit(this._draft);
  }

  nameFocusOut(){
    this.onNameChange.emit(this.id);
  }


  /**
   * Called when main palette is rescaled and triggers call to rescale this element, and update its position 
   * so it remains at the same coords. 
   * @param scale - the zoom scale of the iterface (e.g. the number of pixels to render each cell)
   */
  rescale(){

    

    if(this.draft &#x3D;&#x3D;&#x3D; null){
      return;
    } 

    const zoom_factor:number &#x3D; this.scale/this.default_cell;

    //redraw at scale
    const container: HTMLElement &#x3D; document.getElementById(&#x27;scale-&#x27;+this.id.toString());
   
    if(container &#x3D;&#x3D;&#x3D; null) return;


    container.style.transformOrigin &#x3D; &#x27;top left&#x27;;
    container.style.transform &#x3D; &#x27;scale(&#x27; + zoom_factor + &#x27;)&#x27;;

   
    this.bounds.topleft &#x3D; {
      x: this.interlacement.j * this.scale,
      y: this.interlacement.i * this.scale
    };

    this.bounds.width &#x3D; warps(this.draft.drawdown) * this.scale;
    this.bounds.height &#x3D; wefts(this.draft.drawdown) * this.scale;

  }

  /**called when bounds change, updates the global view port */
  updateViewport(bounds: Bounds){
    this.interlacement &#x3D; utilInstance.resolvePointToAbsoluteNdx(bounds.topleft, this.scale);
    this.viewport.updatePoint(this.id, this.interlacement);

  }

  /**
   * updates this components position based on the input component&#x27;s position
   * */
  updatePositionFromParent(parent: OperationComponent){

    if(this.parent_id !&#x3D;&#x3D; parent.id){
      console.error(&quot;attempitng to update subdraft position from non-parent operation&quot;, this.parent_id, parent.id);
      return;
    }

    const container &#x3D; &lt;HTMLElement&gt; document.getElementById(&quot;scale-&quot;+this.parent_id);
    this.setPosition({x: parent.bounds.topleft.x, y: parent.bounds.topleft.y + (container.offsetHeight * this.scale/this.default_cell) });


  }



  updateSize(parent: OperationComponent){

    const draft &#x3D; this.tree.getDraft(this.id);

    this.bounds.width &#x3D; warps(draft.drawdown) * this.scale;
    this.bounds.height &#x3D; wefts(draft.drawdown) * this.scale;

    if(this.parent_id !&#x3D;&#x3D; parent.id){
      console.error(&quot;attempitng to update subdraft position from non-parent operation&quot;, this.parent_id, parent.id);
      console.log(&quot;attempitng to update subdraft position from non-parent operation&quot;, this.parent_id, parent.id);
      return;
    }

    this.bounds.width &#x3D; Math.max(parent.bounds.width, this.bounds.width);
    this.bounds.height &#x3D; Math.max(parent.bounds.height, this.bounds.height);

  }
  



  /**
   * Called when main palette is rescaled and triggers call to rescale this element, and update its position 
   * so it remains at the same coords. 
   * @param scale - the zoom scale of the iterface (e.g. the number of pixels to render each cell)
   */
   rescaleForBitmap(){

    
    if(this.canvas &#x3D;&#x3D;&#x3D; undefined) return;
    const draft &#x3D; this.tree.getDraft(this.id);


    this.canvas.width &#x3D; warps(draft.drawdown) * this.default_cell;
    this.canvas.height &#x3D; wefts(draft.drawdown) * this.default_cell;

    for (let i &#x3D; 0; i &lt; wefts(draft.drawdown); i++) {
      for (let j &#x3D; 0; j &lt; warps(draft.drawdown); j++) {
        this.drawCell(draft, 1, i, j, false);
      }
    }
  }

  connectionEnded(){
    this.selecting_connection &#x3D; false;
    this.enableDrag();
  }

  connectionStarted(event: any){
    this.selecting_connection &#x3D; true;
    
    this.disableDrag();

    this.onConnectionStarted.emit({
      event: event,
      id: this.id
    });

  }



  /**
   * called on create to position the element on screen
   * @param pos 
   */
  setPosition(pos: Point){
    this.enableDrag();
    this.bounds.topleft &#x3D; pos;
    this.updateViewport(this.bounds);
  }



  public inkActionChange(name: any){
    this.ink &#x3D; name;
    this.inks.select(name);
    //this.drawDraft();
  }

  /**
   * gets the next z-ndx to place this in front
   */
  public setAsPreview(){
    this.is_preview &#x3D; true;
     this.zndx &#x3D; this.layer.createLayer();
  }

 

  /**
   * does this subdraft exist at this point?
   * @param p the absolute position of the coordinate (based on the screen)
   * @returns true/false for yes or no
   */
  public hasPoint(p:Point) : boolean{

      const endPosition &#x3D; {
        x: this.bounds.topleft.x + this.bounds.width,
        y: this.bounds.topleft.y + this.bounds.height,
      };

      if(p.x &lt; this.bounds.topleft.x || p.x &gt; endPosition.x) return false;
      if(p.y &lt; this.bounds.topleft.y || p.y &gt; endPosition.y) return false;

    
    return true;

  }


/**
 * Takes row/column position in this subdraft and translates it to an absolution position  
 * @param ndx the index
 * @returns the absolute position as nxy
 */
 public resolveNdxToPoint(ndx:Interlacement) : Point{
  
  let y &#x3D; this.bounds.topleft.y + ndx.i * this.scale;
  let x &#x3D; this.bounds.topleft.x + ndx.j * this.scale;
  return {x: x, y:y};

}

/**
 * Takes an absolute coordinate and translates it to the row/column position Relative to this subdraft
 * @param p the screen coordinate
 * @returns the row and column within the draft (i &#x3D; row, j&#x3D;col), returns -1 if out of bounds
 */
  public resolvePointToNdx(p:Point) : Interlacement{
    const draft &#x3D; this.tree.getDraft(this.id);

    let i &#x3D; Math.floor((p.y -this.bounds.topleft.y) / this.scale);
    let j &#x3D; Math.floor((p.x - this.bounds.topleft.x) / this.scale);

    if(i &lt; 0 || i &gt;&#x3D; wefts(draft.drawdown)) i &#x3D; -1;
    if(j &lt; 0 || j &gt;&#x3D; warps(draft.drawdown)) j &#x3D; -1;

    return {i: i, j:j, si: i};

  }



/**
 * takes an absolute reference and returns the value at that cell boolean or null if its unset
 * @param p a point of the absolute poistion of coordinate in question
 * @returns true/false/or null representing the eddle value at this point
 */
  public resolveToValue(p:Point) : boolean{

    const coords &#x3D; this.resolvePointToNdx(p);

    if(coords.i &lt; 0 || coords.j &lt; 0) return null; //this out of range
    
    const draft &#x3D; this.tree.getDraft(this.id);

    if(!draft.drawdown[coords.i][coords.j].isSet()) return null;
    
    return isUp(draft.drawdown, coords.i, coords.j);
  
  }


  // /**
  //  * sets a new draft
  //  * @param temp the draft to set this component to
  //  */
  // setNewDraft(temp: Draft) {

  //   this.bounds.width &#x3D; temp.warps * this.scale;
  //   this.bounds.height &#x3D; temp.wefts * this.scale;
  //   this.draft.reload(temp);
  //   this.drawDraft();

  // }

  // setComponentPosition(point: Point){
  //   this.bounds.topleft &#x3D; point;
  // }


  setComponentBounds(bounds: Bounds){
    this.setPosition(bounds.topleft);
    this.bounds &#x3D; bounds;
  }
  /**
   * manually sets the component size. While such an operation should be handled on init but there is a bug where this value is checked before the 
   * component runds its init sequence. Manually adding the data makes it possible for check for intersections on selection and drawing end.
   * @param width 
   * @param height 
   */
  setComponentSize(width: number, height: number){
    this.bounds.width &#x3D; width;
    this.bounds.height &#x3D; height;
  }

  async drawCell(draft, cell_size, i, j, usecolor){
    let is_up &#x3D; isUp(draft.drawdown, i,j);
    let is_set &#x3D; isSet(draft.drawdown, i, j);
    let color &#x3D; &quot;#ffffff&quot;
    if(is_set){
      if(this.ink &#x3D;&#x3D;&#x3D; &#x27;unset&#x27; &amp;&amp; is_up){
        this.cx.fillStyle &#x3D; &quot;#999999&quot;; 
      }else{
        if(is_up){
          color &#x3D; usecolor ? this.ms.getColor(draft.colShuttleMapping[j]) : &#x27;#000000&#x27;;
        }else{
          color &#x3D; usecolor ? this.ms.getColor(draft.rowShuttleMapping[i]) : &#x27;#ffffff&#x27;;
        }
        this.cx.fillStyle &#x3D; color;
      }
    } else{
      this.cx.fillStyle &#x3D;  &#x27;#0000000d&#x27;;
    // this.cx.fillStyle &#x3D;  &#x27;#ff0000&#x27;;

    }
    this.cx.fillRect(j*cell_size, i*cell_size, cell_size, cell_size);
  }

  redrawExistingDraft(){
    this.drawDraft(this.draft);
  }

  /**
   * draw whetever is stored in the draft object to the screen
   * @returns 
   */
  async drawDraft(draft: Draft) : Promise&lt;any&gt; {

    draft &#x3D; this.tree.getDraft(this.id);

    if(this.canvas &#x3D;&#x3D;&#x3D; undefined) return;
    this.cx &#x3D; this.canvas.getContext(&quot;2d&quot;);
   
    if(draft &#x3D;&#x3D;&#x3D; null){
      this.canvas.width &#x3D; 0;
      this.canvas.height &#x3D; 0;

    }else{
      this.canvas.width &#x3D; warps(draft.drawdown) * this.default_cell;
      this.canvas.height &#x3D; wefts(draft.drawdown) * this.default_cell;

      for (let i &#x3D; 0; i &lt;  wefts(draft.drawdown); i++) {
        for (let j &#x3D; 0; j &lt; warps(draft.drawdown); j++) {
          this.drawCell(draft, this.default_cell, i, j, true);
        }
      }
    }
    this.tree.setDraftClean(this.id);
    return &quot;complete&quot;;
  }


  /**
   * draw onto the supplied canvas, to be used when printing
   * @returns 
   */
   drawForPrint(canvas, cx, scale: number) {

    // if(canvas &#x3D;&#x3D;&#x3D; undefined) return;
    // const draft &#x3D; this.tree.getDraft(this.id);

    // for (let i &#x3D; 0; i &lt; draft.wefts; i++) {
    //   for (let j &#x3D; 0; j &lt; draft.warps; j++) {
    //     let is_up &#x3D; draft.isUp(i,j);
    //     let is_set &#x3D; draft.isSet(i, j);
    //     if(is_set){
    //       if(this.ink &#x3D;&#x3D;&#x3D; &#x27;unset&#x27; &amp;&amp; is_up){
    //         cx.fillStyle &#x3D; &quot;#999999&quot;; 
    //       }else{
    //         cx.fillStyle &#x3D; (is_up) ?  &#x27;#000000&#x27; :  &#x27;#ffffff&#x27;;
    //       }
    //     } else{
    //       cx.fillStyle &#x3D;  &#x27;#0000000d&#x27;;
    //     }
    //     cx.fillRect(j*scale+this.bounds.topleft.x, i*scale+this.bounds.topleft.y, scale, scale);
    //   }
    // }

    // //draw the supplemental info like size
    // cx.fillStyle &#x3D; &quot;#666666&quot;;
    // cx.font &#x3D; &quot;20px Verdana&quot;;

    // let datastring: string &#x3D;  draft.warps + &quot; x &quot; + draft.wefts;
    // cx.fillText(datastring,this.bounds.topleft.x + 5, this.bounds.topleft.y+this.bounds.height + 20 );

  }





  /**
   * gets the position of this elment on the canvas. Dyanic top left might be bigger due to scolling intersection
   * previews. Use static for all calculating of intersections, etc. 
   * @returns 
   */
  getTopleft(): Point{
    return this.bounds.topleft;
  }



  
  isSameBoundsAs(bounds: Bounds) : boolean {   
    if(bounds.topleft.x !&#x3D; this.bounds.topleft.x) return false;
    if(bounds.topleft.y !&#x3D; this.bounds.topleft.y) return false;
    if(bounds.width !&#x3D; this.bounds.width) return false;
    if(bounds.height !&#x3D; this.bounds.height) return false;
    return true;
  }
  

  dragEnd($event: any) {
    this.moving &#x3D; false;
    this.counter &#x3D; 0;  
    this.last_ndx &#x3D; {i: -1, j:-1, si: -1};
    this.onSubdraftDrop.emit({id: this.id});
  }

  dragStart($event: any) {
    this.moving &#x3D; true;
    this.counter &#x3D; 0;  
    this.onSubdraftStart.emit({id: this.id});
 

  }

  dragMove($event: any) {
    //position of pointer of the page
    const pointer:Point &#x3D; $event.pointerPosition;

    const relative:Point &#x3D; utilInstance.getAdjustedPointerPosition(pointer, this.viewport.getBounds());
    const adj:Point &#x3D; utilInstance.snapToGrid(relative, this.scale);


    this.bounds &#x3D; ({
      topleft: adj, 
      width: this.bounds.width,
      height: this.bounds.height
    });

    // this.bounds.topleft &#x3D; adj;

     const ndx &#x3D; utilInstance.resolvePointToAbsoluteNdx(adj, this.scale);
    this.interlacement &#x3D; ndx;
    
    if(this.counter%this.counter_limit &#x3D;&#x3D;&#x3D; 0 || !utilInstance.isSameNdx(this.last_ndx, ndx)){
      this.onSubdraftMove.emit({id: this.id, point: adj});
      this.counter &#x3D; 0;
    } 

    this.counter++;
    this.last_ndx &#x3D; ndx;

  }

  disableDrag(){
    this.disable_drag &#x3D; true;
  }

  enableDrag(){
    this.disable_drag &#x3D; false;
  }

  showhide(){
    this.draft_visible &#x3D; !this.draft_visible;
    this.onSubdraftViewChange.emit(this.id);
  }

  connectionClicked(id:number){
    this.has_active_connection  &#x3D; true;
    // if(this.active_connection_order &#x3D;&#x3D;&#x3D; 0){
    //   this.onConnectionMade.emit(id);
    // }else{
    //   this.onConnectionRemoved.emit(id);
    // }


  }

  resetConnections(){
    this.has_active_connection &#x3D; false;
  }



  async designActionChange(e){
    const draft &#x3D; this.tree.getDraft(this.id);

    switch(e){
      case &#x27;duplicate&#x27;:   
      this.onDuplicateCalled.emit({id: this.id});
      break;

      case &#x27;delete&#x27;: 
        this.onDeleteCalled.emit({id: this.id});
      break;

      default: 
        this.onDesignAction.emit({id: this.id});
      break;

    }
  }


  /**
   * Draws to hidden bitmap canvas a file in which each draft cell is represented as a single pixel. 
   * @returns 
   */
  async saveAsBmp() : Promise&lt;any&gt; {

    this.rescaleForBitmap();

    let b &#x3D; this.bitmap.nativeElement;
    let context &#x3D; b.getContext(&#x27;2d&#x27;);
    const draft &#x3D; this.tree.getDraft(this.id);

    b.width &#x3D; (warps(draft.drawdown));
    b.height &#x3D; (wefts(draft.drawdown));
    
    context.fillStyle &#x3D; &quot;white&quot;;
    context.fillRect(0,0,b.width,b.height);
    context.drawImage(this.canvas, 0, 0);

    const a &#x3D; document.createElement(&#x27;a&#x27;)
    return this.fs.saver.bmp(b)
    .then(href &#x3D;&gt; {
      a.href &#x3D;  href;
      a.download &#x3D; getDraftName(draft) + &quot;_bitmap.jpg&quot;;
      a.click();
      this.drawDraft(draft);

    });
    


      
  }
  
    async saveAsAda() : Promise&lt;any&gt;{
      const draft &#x3D; this.tree.getDraft(this.id);

      const a &#x3D; document.createElement(&#x27;a&#x27;);
      return this.fs.saver.ada(&#x27;draft&#x27;, false, this.scale).then(out &#x3D;&gt; {
        a.href &#x3D; &quot;data:application/json;charset&#x3D;UTF-8,&quot; + encodeURIComponent(out.json);
        a.download &#x3D; getDraftName(draft) + &quot;.ada&quot;;
        a.click();
      }); 
    }
  
    async saveAsWif() {

      // const draft &#x3D; this.tree.getDraft(this.id);
      // const loom &#x3D; this.tree.getLoom(this.id);

      
      

      // const a &#x3D; document.createElement(&#x27;a&#x27;);
      // return this.fs.saver.wif(draft, loom)
      // .then(href &#x3D;&gt; {
      //   a.href &#x3D; href;
      //   a.download  &#x3D; getDraftName(draft) +&quot;.wif&quot;;
      //   a.click();
      // });
    
    }
  
    async saveAsPrint() {
     
      let dims &#x3D; this.scale;
      let b &#x3D; this.bitmap.nativeElement;
      let context &#x3D; b.getContext(&#x27;2d&#x27;);

      const draft &#x3D; this.tree.getDraft(this.id);


      b.width &#x3D; warps(draft.drawdown) * dims;
      b.height &#x3D; wefts(draft.drawdown) * dims;
      
      context.fillStyle &#x3D; &quot;white&quot;;
      context.fillRect(0,0,b.width,b.height);
      

      context.drawImage(this.canvas, 0, 0);

      const a &#x3D; document.createElement(&#x27;a&#x27;)
      return this.fs.saver.jpg(b)
        .then(href &#x3D;&gt; {
          a.href &#x3D;  href;
          a.download &#x3D; getDraftName(draft) + &quot;.jpg&quot;;
          a.click();
      
        });
    }

    warps(){
      return warps(this.draft.drawdown);
    }

    wefts(){
      return wefts(this.draft.drawdown);
    }

    finetune(){

      //if this is already open, don&#x27;t reopen it
      if(this.modal !&#x3D; undefined &amp;&amp; this.modal.componentInstance !&#x3D; null) return;
      const draft &#x3D; this.tree.getDraft(this.id);
      const loom &#x3D; this.tree.getLoom(this.id);
      const loom_settings &#x3D; this.tree.getLoomSettings(this.id);

      this.modal &#x3D; this.dialog.open(DraftdetailComponent,
        {disableClose: true,
          hasBackdrop: false,
          data: {
            id: this.id,
            ink: this.inks.getInk(this.ink).viewValue
          }
        });



        this.modal.afterClosed().subscribe(result &#x3D;&gt; {
          if(result !&#x3D; null){
            if(this.parent_id &#x3D;&#x3D; -1){

              console.log(&quot;RESULT&quot;, result);
              //create a new draft here and make sure its assigned
              //this should be happening directly in the tree, and not here
              // this.draft &#x3D; initDraftWithParams({
              //   id: result.id,
              //   gen_name: result.gen_name,
              //   ud_name: result.ud_name,
              //   drawdown: result.drawdown,
              //   rowShuttleMapping: result.rowShuttleMapping,
              //   rowSystemMapping: result.rowSystemMapping,
              //   colSystemMapping: result.colSystemMapping,
              //   colShuttleMapping: result.colShuttleMapping
              // });

              
              // this.tree.setDraft(this.id, this.draft, this.loom_settings);
              this.draft &#x3D; this.tree.getDraft(this.id);

              this.onDesignAction.emit({id: this.id});
            }
          }
        })   
       }

 


}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'DesignActions.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
